name: innovation-matrix
description: Recursive capability Ã— constraint ideation pipeline using the Innovation Matrix method
version: "1.0"

prompts_dir: innovation/prompts

state:
  domain: str
  capabilities: list
  constraints: list
  matrix: dict
  selected: dict
  depth: int
  max_depth: int
  history: list
  final_output: str

nodes:
  # Step 1: Initialize state + extract capabilities and constraints from domain
  analyze_domain:
    type: llm
    prompt: analyze_domain
    variables:
      domain: "{state.domain}"
    state_key: analysis
    temperature: 0.8
    output_schema:
      capabilities:
        type: array
        items: { type: string }
        description: "3-5 key capabilities in this domain"
      constraints:
        type: array
        items: { type: string }
        description: "3-5 key constraints/pressures"
      depth:
        type: integer
        description: "Initial depth value, always 0"
      history:
        type: array
        items: { type: object }
        description: "Empty history array"

  # Step 2: Generate matrix intersections
  generate_matrix:
    type: llm
    prompt: generate_matrix
    variables:
      capabilities: "{state.capabilities}"
      constraints: "{state.constraints}"
      depth: "{state.depth}"
    state_key: matrix
    temperature: 0.9
    output_schema:
      intersections:
        type: array
        items:
          type: object
          properties:
            capability: { type: string }
            constraint: { type: string }
            tension: { type: string }
            idea: { type: string }
            potential: { type: integer }

  # Step 3: Select most promising intersection
  select_intersection:
    type: llm
    prompt: select_intersection
    variables:
      matrix: "{state.matrix}"
      depth: "{state.depth}"
    state_key: selected
    temperature: 0.7
    output_schema:
      capability: { type: string }
      constraint: { type: string }
      tension: { type: string }
      reasoning: { type: string }

  # Step 4: Expand selected intersection into new dimensions
  expand_intersection:
    type: llm
    prompt: expand_intersection
    variables:
      selected: "{state.selected}"
      depth: "{state.depth}"
    state_key: expansion
    temperature: 0.8
    output_schema:
      new_capabilities:
        type: array
        items: { type: string }
      new_constraints:
        type: array
        items: { type: string }
      next_depth:
        type: integer
        description: "Current depth + 1"

  # Step 5: Compile final output
  compile_output:
    type: llm
    prompt: compile_output
    variables:
      domain: "{state.domain}"
      history: "{state.history}"
      selected: "{state.selected}"
      depth: "{state.depth}"
    state_key: final_output
    temperature: 0.7

edges:
  - from: START
    to: analyze_domain
  - from: analyze_domain
    to: generate_matrix
  - from: generate_matrix
    to: select_intersection
  - from: select_intersection
    to: expand_intersection
  - from: expand_intersection
    to: generate_matrix
    condition: "{state.expansion.next_depth} < {state.max_depth}"
  - from: expand_intersection
    to: compile_output
    condition: "{state.expansion.next_depth} >= {state.max_depth}"
  - from: compile_output
    to: END
